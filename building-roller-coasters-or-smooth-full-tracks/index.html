<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta name="theme-color" content="#fff"/><style data-href="/styles.98c208488f7e0918f3b4.css" data-identity="gatsby-global-css">body{margin:8px}.profilepic{border-radius:50%;height:80px;overflow:hidden}#title,.profilepic{vertical-align:middle}#title{background-color:#636363;color:#212121;font-family:sans-serif;font-size:50px;padding:20px;text-align:center;transition:font-size 1s}#title,.title-text{text-decoration:none}.title-text:hover{color:#212121}body{background-color:#333;color:#c4c4c4;font-family:sans-serif;font-size:1.1rem;line-height:1.5}code{font-size:12pt!important}a{color:inherit;transition:color .1s linear}a:hover{color:#fff}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#ccc;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}pre[class*=language-].line-numbers{counter-reset:linenumber;padding-left:3.8em;position:relative}pre[class*=language-].line-numbers>code{position:relative;white-space:inherit}.line-numbers .line-numbers-rows{border-right:1px solid #999;font-size:100%;left:-3.8em;letter-spacing:-1px;pointer-events:none;position:absolute;top:0;-webkit-user-select:none;user-select:none;width:3em}.line-numbers-rows>span{counter-increment:linenumber;display:block}.line-numbers-rows>span:before{color:#999;content:counter(linenumber);display:block;padding-right:.8em;text-align:right}.blog-post-content{margin:auto;max-width:60%;text-align:left}@media screen and (orientation:portrait){.blog-post-content{max-width:100%}}.blog-post-content img{max-width:100%}.blog-post-container{text-align:center}.gatsby-highlight pre[class*=language-].line-numbers{overflow:initial;padding:0 0 0 2.8em}</style><link rel="icon" href="/favicon-32x32.png?v=a60a5f8134c1a0a70ea7cd9216912b32" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="alternate" type="application/rss+xml" title="Ajay Ramachandran&#x27;s Blog" href="/rss.xml"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div id="title"><img src="/ajay_profile.jpg" class="profilepic"/> <a class="title-text" href="/">Ajay Ramachandran</a></div><main><div class="blog-post-container"><div class="blog-post"><h1>Building Roller Coasters | Smooth Full Tracks | Voster Coaster VR Game</h1><h2>July 16, 2018</h2><div class="blog-post-content"><p><img src="/images/QmX6ECfwryqgBVLK5U9SNJzWZn2nQ3KV2pN3W2hP6UpnzR" alt="Added Smooth Tracks.gif"></p>
<h3>In VR</h3>
<p>Sorry for the shakiness, that's just how shaky the human head is, I should probably try stabilizing it next time.</p>
<p><img src="/images/QmbJbRDG4gkNvUvY9LzbajBXeYUrqei5hxN9u2z3mFAAF1" alt="smooth tracks vr.gif"></p>
<h3>What it looked like before</h3>
<p><img src="/images/QmYXqYkTuDU6w3YV1vp2HD3QNHPWognJXxyKUBSGZaU43S" alt="image.gif"></p>
<h1>Repository</h1>
<p><a href="https://github.com/ajayyy/VosterCoasterVR">https://github.com/ajayyy/VosterCoasterVR</a></p>
<h1>Fixed Curve Calculations</h1>
<p>The curve calculations ended up having to be redone entirely.</p>
<p>I started having big issues with how the track curve was being calculated when an angle was above 135 degrees, and tried many different things to try to fix it, including even trying to calculate the error made because the tracks are not actually curves, they are actually shapes with 10 segments (bones). However, that turned out not to have a noticeable enough difference to matter, and the calculations required way too much time to be feasible to be run every frame.</p>
<h4>The margin of error calculation</h4>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//because the track pieces are not actual circles and are made up of straight segments, the margin of error must be calculated
public float getDistanceForAngle(float adjustmentAngle, float currentDistance, int amount) {

    //total displacement on each axis
    float totalX = 0;
    float totalY = 0;

    for(int i = 0; i &lt; amount; i++) {
        //calculate x value for this segment
        float x = Mathf.Sin(adjustmentAngle * (i + 1) * Mathf.Deg2Rad) * (currentDistance / Mathf.Sin(Mathf.PI / 2));
        //calculate y using x in the pythagorean formula
        float y = Mathf.Sqrt(Mathf.Pow(currentDistance, 2) - Mathf.Pow(x, 2));

        totalX += x;
        totalY += y;
    }

    float totalDisplacement = Mathf.Sqrt(Mathf.Pow(totalX, 2) + Mathf.Pow(totalY, 2));

    //find the factor of error this displacement has versus the ideal
    float differenceFactor = ((rollerCoaster.trackBoneSize / RollerCoaster.scale) * amount) / totalDisplacement;

    //multiply this error factor by the current distance and return it to be the real distance
    return currentDistance * differenceFactor;
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>This function calculates the length of each segment, then calculates the x and y displacement to get there. It then adds all these up and calculates the total displacement to be able to compare it with the perfect displacement (with a circle). This will fix the error, but it is not worth the extra computational time.</p>
<h4>How the new curve calculations work</h4>
<p><img src="/images/QmZL7tZWNgZtoNw5Di8PR1DhrAXFkjc1ryx73NVBsCB1aP" alt="thing 2.png"></p>
<p>In this image, the line on the right represents the start angles (linear formulas), and the left line represents the target. The top red points on each line represent the positions (start and target). A line is created from the start point at the angle <code class="language-text">(180 - targetAngle) / 2</code> (represented by angle A in the diagram). Using this line, the collision point between this line and the target line can be found (represented by the lower red dot on the target line in the diagram). This point and the start point are now two positions on the circle.</p>
<p>To calculate the radius, a ratio is calculation.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//y = rsinA, x = rcosA
//these are the positions of these angles on a circle with a radius of 1
float targetNormalX = Mathf.Cos((-targetAngle.y + 360) * Mathf.Deg2Rad);
float targetNormalY = Mathf.Sin((-targetAngle.y + 360) * Mathf.Deg2Rad);
float startNormalX = Mathf.Cos(startTrackAngleRelative.y * Mathf.Deg2Rad);
float startNormalY = Mathf.Sin(startTrackAngleRelative.y * Mathf.Deg2Rad);

//the radius would be equal to 1 for a circle like this. Find how much the distances between the points account for the radius of the circle
float percentageOfRadius = Mathf.Sqrt(Mathf.Pow(startNormalX - targetNormalX, 2) + Mathf.Pow(startNormalY - targetNormalY, 2));</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>This finds the ratio between the distance between these points, and the radius on a circle of radius 1 (to make it easier). This ratio can then be used to calculate the radius of the full circle.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//radius of the curve using the percentage calculations from above
float radius = Mathf.Sqrt(Mathf.Pow(circleStartX - targetPosition.x, 2) + Mathf.Pow(circleStartY - targetPosition.z, 2)) / percentageOfRadius;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>Then, all that's left is to calculate how many tracks need to be drawn to create that curve, and how many to reach the target from that curve.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//calculate the cirumference of this circle multiplied by the amount this curve takes up of the whole circle
float curveLength = 2 * Mathf.PI * radius * (smallestAngleDifference.y / 360f);

curveTracksNeeded = (curveLength / (trackBoneSize * 10f));

startTracksNeeded = 0;

//Find difference between circleTarget and the target position
targetTracksNeeded = (Mathf.Sqrt(Mathf.Pow(circleTargetX - targetPosition.x, 2) + Mathf.Pow(circleTargetY - targetPosition.z, 2)) / (trackBoneSize * 10f));</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Now the amount of tracks to create a curve and reach the target point are created.</p>
<p>This only applied if the tracks to the target needed is more than the tracks to the start needed. If more tracks are needed to reach the start, a similar process is done, except in the other way.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//find intersection between line to the start of curve from the end of curve
float endToStartCurveSlope = Mathf.Tan((((180 - targetAngle.y) / 2)) * Mathf.Deg2Rad);
//the b value (b = y - mx)
float endToStartCurveB = targetPosition.z - endToStartCurveSlope * targetPosition.x;

//find intersection between this line and the start line (x = (b2 - b1) / (m1 - m2))
//this position will be the second point on the circle of the curve (end point), the first is the target track
float circleStartX = (endToStartCurveB - startB) / (startSlope - endToStartCurveSlope);
float circleStartY = endToStartCurveSlope * circleStartX + endToStartCurveB;

//y = rsinA, x = rcosA
//these are the positions of these angles on a circle with a radius of 1
float targetNormalX = Mathf.Cos((-targetAngle.y + 360) * Mathf.Deg2Rad);
float targetNormalY = Mathf.Sin((-targetAngle.y + 360) * Mathf.Deg2Rad);
float startNormalX = Mathf.Cos(startTrackAngleRelative.y * Mathf.Deg2Rad);
float startNormalY = Mathf.Sin(startTrackAngleRelative.y * Mathf.Deg2Rad);

//the radius would be equal to 1 for a circle like this. Find how much the distances between the points account for the radius of the circle
float percentageOfRadius = Mathf.Sqrt(Mathf.Pow(startNormalX - targetNormalX, 2) + Mathf.Pow(startNormalY - targetNormalY, 2));

//radius of the curve using the percentage calculations from above
float radius = Mathf.Sqrt(Mathf.Pow(circleStartX - targetPosition.x, 2) + Mathf.Pow(circleStartY - targetPosition.z, 2)) / percentageOfRadius;

//calculate the cirumference of this circle multiplied by the amount this curve takes up of the whole circle
float curveLength = 2 * Mathf.PI * radius * (smallestAngleDifference.y / 360f);

curveTracksNeeded = (curveLength / (trackBoneSize * 10f));

//Find difference between circleTarget and the target position
startTracksNeeded = (Mathf.Sqrt(Mathf.Pow(circleStartX - startPosition.x, 2) + Mathf.Pow(circleStartY - startPosition.z, 2)) / (trackBoneSize * 10f));

targetTracksNeeded = 0;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h1>Creating a Smoothly Moving Track Segment</h1>
<p>You can see in the old gif how choppy the translations move. This is because the track amounts are stored as integers, and full track pieces are placed each time. This does not produce a smooth or accurate track. To fix this, these numbers need to be saved as floats (number with decimals), and if necessary, only part of the track should be drawn. This makes the track more accurate to reach the target point, and makes the track movement very smooth.</p>
<p>To do this, the track has to be able to only draw a percentage of the track.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//cut this off to make sure it is only the percentageOfTrack
for (int i = 0; i &lt; rails.Length; i++) {
    for (int r = 1; r &lt; rails[i].Length; r++) {
        //if the curve start is normal, treat this normally, otherwise just use the start angle
        if (secondCurveStart == -1) {
            currentAngle = adjustmentAngle;
        } else {
            currentAngle = startAngle;
        }

        if ((r - 1) / boneAmount &gt; percentageOfTrack &amp;&amp; secondCurveStart != -1) {
            //if the curve start is not zero, treat the rest of the track as the upcomming angle instead of the start angle
            rails[i][r].transform.localPosition = defaultBonePosition;
            rails[i][r].transform.localEulerAngles = adjustmentAngle;
            rails[i][r].SetActive(true);
        } else if ((r - 1) / boneAmount &gt; percentageOfTrack &amp;&amp; secondCurveStart == -1) {
            //if the curve start is zero, then treat the rest of the track as if it does not exist
            rails[i][r].transform.localPosition = Vector3.zero;
            rails[i][r].transform.localEulerAngles = Vector3.zero;
            rails[i][r].SetActive(false);
        } else if ((r + 1 - 1) / boneAmount &gt; percentageOfTrack &amp;&amp; percentageOfTrack != 1) {
            rails[i][r].transform.localPosition = ((percentageOfTrack - ((r - 1) / boneAmount)) * boneAmount) * defaultBonePosition;
            rails[i][r].transform.localEulerAngles = ((percentageOfTrack - ((r - 1) / boneAmount)) * boneAmount) * currentAngle;
            rails[i][r].SetActive(true);
        }
    }
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>This code cuts the track off if it has passed the percentage needed to draw, and will only draw part of it if necessary.</p>
<p>This smooths it out a bit, but the way the track is drawn, there are three sections.
<img src="/images/QmTB2MKMxxKxJ3t6Uz6BTfLmGAzSMwCrTY6a9KF6C5uX13" alt="image.png">
<img src="/images/Qmbe95XSn8MB4249gciu5yxjTteNuDHMnLhEBmmQfPojVj" alt="image.png"></p>
<p>Between each of these, these partial tracks need to be merged into one. To do this, as seen in the above code snippet, a variable called <code class="language-text">secondCurveStart</code> is used. This variable specifies where a second curve inside of the track can start. This makes it so that a track can start off curving in one direction, and finish off curving in another direction.</p>
<p>This same technique is used when combining two different track segments into one.</p>
<p><img src="/images/QmVp6L66wwCt2ggscN9Bsiq49nwhNpj6AXSx4BKzdCznQD" alt="image.png"></p>
<p>As you can see, these merged areas are unnoticeable, which is exactly what is required to create a smooth looking track.</p>
<p>The angles are now checked to make sure they intersect properly to create a proper curve as well.</p>
<h1>Attaching a second track segement</h1>
<p>To continue to do the same math as before, but with the start track at a different angle, all of the positions are rotated in the direction of the angle.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//rotate ppositions around the start angle
targetPosition = RotatePointAroundPivot(targetPosition, startPosition, -currentAngle);
targetAngle -= currentAngle;
startTrackAngleRelative = Vector3.zero;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>When combining the track segments, the start track has to merge with the second track segment. This is not normal as the start track is not considered part of the track segment, so it needs to store data about it's previous positions and angles in case the new segment is removed or edited.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">public Vector3 totalAngle = new Vector3(0, 0, 0);
//used when one track piece has mutliple angles on it
public Vector3 startAngle = new Vector3(0, 0, 0);
public float percentageOfTrack = 1;
public float secondCurveStart = -1;
//has this track piece been modified by the current incomplete track
public bool modified = false;
public Vector3 oldTotalAngle = Vector3.zero;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>The modified variable is used to know that the track has been modified and is not in it's normal position. This is used when resetting the track position.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">//reset last track back to normal if nessesary
if(totalTracksNeeded() == 0 &amp;&amp; startTrack.GetComponent&lt;TrackPiece&gt;().modified) {
    TrackPiece trackPiece = startTrack.GetComponent&lt;TrackPiece&gt;();

    Vector3 oldPosition = trackPiece.transform.position;
    Vector3 oldAngles = trackPiece.transform.eulerAngles;

    //reset position and angle before adjusting the track
    trackPiece.transform.position = Vector3.zero;
    trackPiece.transform.localEulerAngles = Vector3.zero;

    //adjust the track back the how it was
    trackPiece.AdjustTrack(trackPiece.oldTotalAngle, Vector3.zero, trackPiece.percentageOfTrack, -1);

    //set it to what it was before
    trackPiece.transform.position = oldPosition;
    trackPiece.transform.localEulerAngles = oldAngles;

    startTrack.GetComponent&lt;TrackPiece&gt;().modified = false;
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h1>Bonus</h1>
<p>Here is a weird bug I found along the way.</p>
<p><img src="/images/QmRgrp54RZKYyNp2E2LKPCDPe6fq3xDxbaknACBrcs35g7" alt="image.png"></p>
<h1>Pull Request</h1>
<p><a href="https://github.com/ajayyy/VosterCoasterVR/pull/10">https://github.com/ajayyy/VosterCoasterVR/pull/10</a> (just cleanup)
<a href="https://github.com/ajayyy/VosterCoasterVR/pull/11">https://github.com/ajayyy/VosterCoasterVR/pull/11</a> (redoing all bad curve calculations)
<a href="https://github.com/ajayyy/VosterCoasterVR/pull/12">https://github.com/ajayyy/VosterCoasterVR/pull/12</a> (everything else)</p>
<p>You can see the full set of changes in the pull request. This post only includes an overview of major changes.</p>
<h1>GitHub Account</h1>
<p><a href="https://github.com/ajayyy">https://github.com/ajayyy</a></p></div></div></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/building-roller-coasters-or-smooth-full-tracks";window.___webpackCompilationHash="ee9f93a22f5d812d53ee";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-2027c615c2b1d449723b.js"],"app":["/app-a8a88917d557b5d5c239.js"],"component---src-pages-404-js":["/component---src-pages-404-js-6e293d823d5e173acc7a.js"],"component---src-pages-index-js":["/component---src-pages-index-js-4c00f30d3c318a368679.js"],"component---src-pages-sponsorblock-js":["/component---src-pages-sponsorblock-js-03e17db57ab08e6d8408.js"],"component---src-pages-vostercoaster-js":["/component---src-pages-vostercoaster-js-dee0d7b7fa6b58872b3e.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-d0d2c490581e9ed2d6f1.js"]};/*]]>*/</script><script src="/polyfill-2027c615c2b1d449723b.js" nomodule=""></script><script src="/app-a8a88917d557b5d5c239.js" async=""></script><script src="/framework-c0acfd4b44c09a0159f3.js" async=""></script><script src="/webpack-runtime-f415ec79cfe5feaa0178.js" async=""></script></body></html>