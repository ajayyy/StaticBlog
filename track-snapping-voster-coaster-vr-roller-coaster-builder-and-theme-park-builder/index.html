<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta name="theme-color" content="#fff"/><style data-href="/styles.98c208488f7e0918f3b4.css" data-identity="gatsby-global-css">body{margin:8px}.profilepic{border-radius:50%;height:80px;overflow:hidden}#title,.profilepic{vertical-align:middle}#title{background-color:#636363;color:#212121;font-family:sans-serif;font-size:50px;padding:20px;text-align:center;transition:font-size 1s}#title,.title-text{text-decoration:none}.title-text:hover{color:#212121}body{background-color:#333;color:#c4c4c4;font-family:sans-serif;font-size:1.1rem;line-height:1.5}code{font-size:12pt!important}a{color:inherit;transition:color .1s linear}a:hover{color:#fff}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#ccc;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}pre[class*=language-].line-numbers{counter-reset:linenumber;padding-left:3.8em;position:relative}pre[class*=language-].line-numbers>code{position:relative;white-space:inherit}.line-numbers .line-numbers-rows{border-right:1px solid #999;font-size:100%;left:-3.8em;letter-spacing:-1px;pointer-events:none;position:absolute;top:0;-webkit-user-select:none;user-select:none;width:3em}.line-numbers-rows>span{counter-increment:linenumber;display:block}.line-numbers-rows>span:before{color:#999;content:counter(linenumber);display:block;padding-right:.8em;text-align:right}.blog-post-content{margin:auto;max-width:60%;text-align:left}@media screen and (orientation:portrait){.blog-post-content{max-width:100%}}.blog-post-content img{max-width:100%}.blog-post-container{text-align:center}.gatsby-highlight pre[class*=language-].line-numbers{overflow:initial;padding:0 0 0 2.8em}</style><link rel="icon" href="/favicon-32x32.png?v=a60a5f8134c1a0a70ea7cd9216912b32" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=a60a5f8134c1a0a70ea7cd9216912b32"/><link rel="alternate" type="application/rss+xml" title="Ajay Ramachandran&#x27;s Blog" href="/rss.xml"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div id="title"><img src="/ajay_profile.jpg" class="profilepic"/> <a class="title-text" href="/">Ajay Ramachandran</a></div><main><div class="blog-post-container"><div class="blog-post"><h1>Track Snapping - Voster Coaster - VR Roller Coaster Builder and Theme Park Builder</h1><h2>March 14, 2018</h2><div class="blog-post-content"><h1>Placement</h1>
<p><img src="/images/gztp2taqnxzvkrt0vycn.png" alt="image.png"></p>
<p>Before, in my proof of concept build, you could drop a full roller coaster in mid-air, and it would fall to the ground. Now, I have changed that entirely.</p>
<p>You now have pieces of a roller coaster, that are placed on the ground below you. They always are on the ground, and it does not rely on the physics to drop it down.</p>
<p>This is done by creating a raycast (a ray that is cast in a direction to find objects) toward the ground to find the nearest ground.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">RaycastHit hit;
if (Physics.Raycast(rightController.transform.position, Vector3.down, out hit)) {
        Vector3 spawnPosition = hit.point;
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>The raycast collision point is then recorded, and used to figure out where to spawn the track. This point will be the nearest ground from the controller's position.</p>
<h1>Issues with the Raycast</h1>
<p>The raycast will not work perfectly because it is a ray (line) that is cast straight from the controller position (this made it so that it only snapped if the middle of the track was on that level of ground), but the track is a certain width. To fix this, I decided to use a box cast instead. A box cast can have a set size, and will find the first object (closest object) within that radius.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">RaycastHit groundHit;

bool groundBoxCastCollided = Physics.BoxCast(rightController.transform.position, (options[currentCoaster].GetComponent&lt;BoxCollider&gt;()).size * options[currentCoaster].transform.localScale.x / 2, Vector3.down, out groundHit, Quaternion.Euler(new Vector3(180, 0, 0)));</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>This grabs makes a box cast downward, from the right controller's position, with the sizeof the current coaster options boxcollider multiplied by it's scale (as everything is scaled down).</p>
<h1>Track Snapping</h1>
<p><img src="/images/qivvfypgytelpkpkuvfj.png" alt="image.png"></p>
<p>Another feature I added was the ability for tracks to snap together. If you attempt to place a track on another track, it will snap it beside it, to the closest side. This takes the boxraycast and checks if there is a game object with the tag "Track" under it. If so, it can calculate the position necessary to spawn it.</p>
<div class="gatsby-highlight" data-language="c#"><pre style="counter-reset: linenumber NaN" class="language-c# line-numbers"><code class="language-c#">if (groundHit.collider.gameObject.tag == &quot;Track&quot;) {

                        Vector3 spawnPositionForward = groundHit.collider.gameObject.transform.position + (groundHit.collider.gameObject.transform.forward * ((BoxCollider)groundHit.collider).size.z) * groundHit.collider.gameObject.transform.localScale.x;
                        Vector3 spawnPositionBackward = groundHit.collider.gameObject.transform.position + ((-groundHit.collider.gameObject.transform.forward) * ((BoxCollider)groundHit.collider).size.z) * groundHit.collider.gameObject.transform.localScale.x;

                        float distForward = Vector3.Distance(currentThumbnail.transform.position, spawnPositionForward);
                        float distBackward = Vector3.Distance(currentThumbnail.transform.position, spawnPositionBackward);

                        if(distForward &lt; distBackward) {
                            spawnPosition = spawnPositionForward;
                        } else {
                            spawnPosition = spawnPositionBackward;
                        }

                        spawnRotation = groundHit.collider.gameObject.transform.eulerAngles.y;
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>This takes advantage of the BoxCast as it can now snap even when only part of the track is touching the other.</p>
<h1>Other changes</h1>
<p>I also added some other miscellaneous changes to prepare for future features, like the spline based roller coaster creator.</p>
<h1>Next Steps</h1>
<p>My next plan is to add the ability to customize the steepness of each track piece. This will help lead to the eventual ability to just select different points and have the program automatically make a track between them.</p>
<p>These features to rely less on the physics engine and do more manually help reach that goal, and make the overall experience more consistent and less processor intensive.</p>
<h1>Thanks for the models!</h1>
<p>Thank you so much everyone for making such awesome models, I plan to add them all in once I'm done the basic roller coaster building.</p></div></div></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/track-snapping-voster-coaster-vr-roller-coaster-builder-and-theme-park-builder";window.___webpackCompilationHash="ee9f93a22f5d812d53ee";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-2027c615c2b1d449723b.js"],"app":["/app-a8a88917d557b5d5c239.js"],"component---src-pages-404-js":["/component---src-pages-404-js-6e293d823d5e173acc7a.js"],"component---src-pages-index-js":["/component---src-pages-index-js-4c00f30d3c318a368679.js"],"component---src-pages-sponsorblock-js":["/component---src-pages-sponsorblock-js-03e17db57ab08e6d8408.js"],"component---src-pages-vostercoaster-js":["/component---src-pages-vostercoaster-js-dee0d7b7fa6b58872b3e.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-d0d2c490581e9ed2d6f1.js"]};/*]]>*/</script><script src="/polyfill-2027c615c2b1d449723b.js" nomodule=""></script><script src="/app-a8a88917d557b5d5c239.js" async=""></script><script src="/framework-c0acfd4b44c09a0159f3.js" async=""></script><script src="/webpack-runtime-f415ec79cfe5feaa0178.js" async=""></script></body></html>